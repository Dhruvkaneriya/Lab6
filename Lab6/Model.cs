/* Lab Question  (Test 2)
 * 
 * A bottom-up approach is typically used in OOP languages. This is the general design approach that has been used
 * for this software. Do you think it would have been easier or harder to approach this project using a top-down approach?
 * Why do you think a bottom up approach is generally more natural when using OOP languages?
 *
 */

using System;
using System.Collections.Generic;

using Lab6.ModelComponents;
using Lab6.Materials;

namespace Lab6
{
	// Model is comprised of a single material. Hardcoding the time step & number of phonons for now.
	class Model
	{
		private const double TIME_STEP = 5e-12;
		private const int NUM_PHONONS = 10000000;
		private Material material;
		private List<Cell> cells = new() { };
		private List<Sensor> sensors = new() { };
        private object sensor;
        private object sensorsID;
        private readonly double highTemp;
		private readonly double lowTemp;
		private readonly double simTime;
		private readonly double tEq;

		public Model(Material material, double highTemp, double lowTemp, double simTime)
		{
			this.material = material;
			this.highTemp = highTemp;
			this.lowTemp = lowTemp;
			this.simTime = simTime;
			tEq = (highTemp + lowTemp) / 2;
		}

		// TODO: Write a method to add a sensor to the model
		public void AddSensor(int sensorID, double initTemp)
		{
			// we can not have duplicate sensor id so if sensor with sensor id already exits
			// in the model (sensor list) throw invalid exception
			// otherwise, add sensor to the model
				List<Sensor> sensor = new List<Sensor>();
				if (sensor == sensorsID)
				{
					throw new NotImplementedException();
				}
				else
				{
					sensors.Add(new Sensor(sensorID, material, initTemp));
				}
		}

		public void AddSensor(double inintTemp)
		{
			// use auto incrementing sensor id
			int sensorID = 0;
			sensorID += 1;
		}

		// TODO: Write a method to add a cell to the model
		public void AddCell(double length, double width, double sensorID)
		{
			// look throw the sensor list, find the sensor with Id sensor ID
			// create a cell that link to sensor 
			// what to do if no sensor with sensorID exits?
			List<Sensor> sensor = new List<Sensor>();
			if (sensor == sensorsID)
			{
				throw new NotImplementedException();

			}
			else
			{
				cells.Add(new Cell(length, width, sensorID));
			}
		}

		/// <summary>
		/// Automatically sets all the surfaces in the cells that constitute this model.
		/// Should be called after all the cells have been added
		/// </summary>
		/// <param name="tEq">The equilibrium temperature of the system</param>
		private void SetSurfaces(double tEq)
		{
			// TODO: Implemenent -> Assume that the system is linear!!
			int numCells = cells.Count;
			if (numCells < 2)
			{
				// throw custom exception
			}
			// Continue with implementation
			throw new NotImplementedException();
		}

		/// <summary>
		/// Calibrates the emitting surfaces in the model.
		/// </summary>
		/// <param name="tEq">System equilibrium temperature</param>
		/// <param name="effEnergy">Phonon packet effective energy</param>
		/// <param name="timeStep">Simulation time step</param>
		private void SetEmitPhonons(double tEq, double effEnergy, double timeStep)
		{
			// TODO: Implement -> just need to call the appropriate method in each cell
			
			throw new NotImplementedException();
		}

		/// <summary>
		/// Returns the total energy of the model (initial energy + emit energy)
		/// </summary>
		/// <returns>Total energy generated by the model over the course of the simulation</returns>
		private double GetTotalEnergy()
		{
			// TODO: Implement -> just need to call the appropriate method in each cell
			throw new NotImplementedException();
		}
	}
}
